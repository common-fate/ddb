package ddbmock

import (
	"context"
	"errors"
	"fmt"
	"reflect"

	"github.com/common-fate/ddb"
	"github.com/golang/mock/gomock"
)

// matcher is a custom matcher for using ddb Access Patterns
// with GoMock. It implement's GoMock's matcher interface.
// It matches queries of the same Go type.
//
// For example, &testQuery{ID: 1} will match &testQuery{}
// as they are both of type 'testQuery'.
type matcher struct {
	// qt is the type of the query
	qt reflect.Type
}

// queryMatcher creates a new Matcher for matching queries
// when ddb is used with GoMock.
func queryMatcher(qb ddb.QueryBuilder) gomock.Matcher {
	return &matcher{qt: reflect.TypeOf(qb)}
}

// Matches returns whether arg is a match.
func (m *matcher) Matches(arg interface{}) bool {
	return m.qt == reflect.TypeOf(arg)
}

// String describes what the matcher matches.
func (m *matcher) String() string {
	return fmt.Sprintf("is the same type as %s", m.qt)
}

// GoMockQuery allows ddb queries to be mocked when GoMock is used.
// The provided 'query' arg will define the mocked results of the query.
//
// Example usage:
//
//	m := MockStorage{} // MockStorage is a GoMock generated mock.
//	ddbmock.GoMockQuery(m, &getApple{Result: Apple{Color: "red"}})
//
//	var got testQuery
//	m.Query(ctx, &got)
//	// &got now contains {Result: Apple{Color: "red"}} as defined by GoMockQuery.
//
// It assumes that you have an interface defined as follows:
//	type Storage interface {
//		Query(ctx context.Context, qb ddb.QueryBuilder) error
//	}
//
// Which is being mocked with GoMock to create a struct:
//
//	type MockStorage struct {
// 		ctrl     *gomock.Controller
// 		recorder *MockStorageMockRecorder
// 	}
//
// MockStorage must be provided as the first argument to GoMockQuery, e.g.
//	m := MockStorage{}
//	GoMockQuery(m, &myQuery{})
//
// It panics if goMockStorage is not a mock generated by GoMock.
func GoMockQuery(goMockStorage interface{}, query ddb.QueryBuilder) *gomock.Call {
	call := callGoMockQuery(goMockStorage, query)
	return call.DoAndReturn(func(_ context.Context, result ddb.QueryBuilder) error {
		// set the value of the QueryBuilder to our stored mock result.
		reflect.ValueOf(result).Elem().Set(reflect.ValueOf(query).Elem())
		return nil
	})
}

// GoMockQueryErr allows ddb queries to be mocked when GoMock is used.
// It works the same as GoMockQuery, but allows an error response to the query to be mocked.
// If err is nil, this method behaves identically to GoMockQuery and sets the query results
// to the query provided in the arguments.
// If err is not nil, the error is returned.
//
// Usage:
//	m := MockStorage{} // MockStorage is a GoMock generated mock.
//	ddbmock.GoMockQueryErr(m, &getApple{}, ddb.ErrNoItems)
//
//	err := m.Query(ctx, &getApples{})
//	// err is ddb.ErrNoItems
func GoMockQueryErr(goMockStorage interface{}, query ddb.QueryBuilder, err error) *gomock.Call {
	call := callGoMockQuery(goMockStorage, query)
	return call.DoAndReturn(func(_ context.Context, result ddb.QueryBuilder) error {
		if err != nil {
			return err
		}

		// set the value of the QueryBuilder to our stored mock result.
		reflect.ValueOf(result).Elem().Set(reflect.ValueOf(query).Elem())
		return nil
	})
}

// callGoMockQuery calls goMockStorage.EXPECT().Query().
// We use reflection to call the methods as we don't have a defined interface for
// the generated GoMock struct.
func callGoMockQuery(goMockStorage interface{}, query ddb.QueryBuilder) *gomock.Call {
	v := reflect.ValueOf(goMockStorage)

	m := v.MethodByName("EXPECT")
	if !m.IsValid() {
		err := errors.New("could not find an EXPECT() method on goMockStorage. Ensure that you are using GoMockQuery with a mock generated from GoMock.")
		panic(err)
	}

	// EXPECT() returns *MockStorageMockRecorder
	recorder := m.Call(nil)[0]
	m = recorder.MethodByName("Query")
	if !m.IsValid() {
		err := errors.New("could not find an Query() method after calling EXPECT(). Ensure that you are using GoMockQuery with a mock generated from GoMock.")
		panic(err)
	}

	// call Query(ctx, matcher)
	ctx := context.Background()
	matcher := queryMatcher(query)
	res := m.Call([]reflect.Value{reflect.ValueOf(ctx), reflect.ValueOf(matcher)})

	// Query() returns a *gomock.Call
	call, ok := res[0].Interface().(*gomock.Call)
	if !ok {
		err := errors.New("could not convert Query() result to *gomock.call. Ensure that you are using GoMockQUery with a mock generated from GoMock.")
		panic(err)
	}
	return call
}
